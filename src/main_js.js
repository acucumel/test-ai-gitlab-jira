const JiraApi = require('node-jira-client');
const shell = require('shelljs');
const fs = require('fs-extra');
const path = require('path');
const winston = require('winston');
require('dotenv').config();

// üìä Configuration logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    new winston.transports.File({ filename: 'logs/automation.log' })
  ]
});

class JiraClaudeAutomation {
  constructor() {
    this.jira = new JiraApi({
      protocol: 'https',
      host: process.env.JIRA_HOST,
      username: process.env.JIRA_USERNAME,
      password: process.env.JIRA_API_TOKEN,
      apiVersion: '2',
      strictSSL: true
    });
    
    this.workingDir = process.env.WORKING_DIR || '/workspace';
    this.projectKey = process.env.JIRA_PROJECT_KEY;
    this.targetLabels = process.env.TARGET_LABELS?.split(',') || ['claude-automation'];
  }

  async initialize() {
    await fs.ensureDir(this.workingDir);
    await fs.ensureDir('logs');
    
    if (!shell.which('claude-code')) {
      throw new Error('Claude Code CLI non install√©');
    }
    
    logger.info('‚úÖ Initialisation termin√©e');
  }

  async getTasksFromBacklog() {
    try {
      const jql = `project = "${this.projectKey}" AND status = "To Do" AND labels IN (${this.targetLabels.map(l => `"${l}"`).join(',')}) ORDER BY priority DESC, created ASC`;
      
      logger.info(`üîç JQL: ${jql}`);
      
      const searchResults = await this.jira.searchJira(jql, {
        startAt: 0,
        maxResults: 10,
        fields: ['summary', 'description', 'priority', 'labels', 'assignee', 'key']
      });

      return searchResults.issues.map(issue => ({
        key: issue.key,
        summary: issue.fields.summary,
        description: issue.fields.description,
        priority: issue.fields.priority?.name,
        labels: issue.fields.labels?.map(l => l.name) || [],
        assignee: issue.fields.assignee?.displayName
      }));
    } catch (error) {
      logger.error('‚ùå Erreur r√©cup√©ration t√¢ches:', error.message);
      throw error;
    }
  }

  async setupGitRepository(task) {
    const repoUrl = process.env.REPOSITORY_URL;
    const defaultBranch = process.env.DEFAULT_BRANCH || 'main';
    const taskDir = path.join(this.workingDir, task.key);
    
    await fs.ensureDir(taskDir);
    shell.cd(taskDir);
    
    logger.info(`üåø Setup Git pour ${task.key}`);
    
    // Clone repository
    if (!fs.existsSync('.git')) {
      if (!repoUrl) {
        throw new Error('REPOSITORY_URL manquante');
      }
      
      const cloneResult = shell.exec(`git clone ${repoUrl} .`);
      if (cloneResult.code !== 0) {
        throw new Error(`√âchec clone: ${cloneResult.stderr}`);
      }
    }
    
    // Configuration Git
    shell.exec('git config user.email "jira-automation@company.com"');
    shell.exec('git config user.name "Jira Claude Automation"');
    
    // Checkout et mise √† jour
    shell.exec(`git checkout ${defaultBranch}`);
    shell.exec('git pull origin ' + defaultBranch);
    
    // Nouvelle branche
    const branchName = `feature/${task.key.toLowerCase()}-${task.summary.toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 50)}`;
    const branchResult = shell.exec(`git checkout -b ${branchName}`);
    
    if (branchResult.code !== 0) {
      logger.warn(`Branche existe, checkout ${branchName}`);
      shell.exec(`git checkout ${branchName}`);
    }
    
    return { taskDir, branchName, defaultBranch };
  }

  async runAutomatedTests(taskDir) {
    shell.cd(taskDir);
    logger.info('üß™ Tests automatis√©s...');
    
    // Tests Maven (Java)
    if (fs.existsSync('pom.xml')) {
      logger.info('‚òï Tests Maven d√©tect√©s...');
      // V√©rifier si Maven est install√©
      if (shell.which('mvn')) {
        const testResult = shell.exec('mvn test');
        return {
          success: testResult.code === 0,
          output: testResult.stdout,
          error: testResult.stderr,
          type: 'maven'
        };
      } else {
        logger.warn('‚ö†Ô∏è  Maven non install√©, tentative avec wrapper...');
        // Essayer avec Maven wrapper
        if (fs.existsSync('mvnw') || fs.existsSync('mvnw.cmd')) {
          const wrapper = process.platform === 'win32' ? 'mvnw.cmd' : './mvnw';
          const testResult = shell.exec(`${wrapper} test`);
          return {
            success: testResult.code === 0,
            output: testResult.stdout,
            error: testResult.stderr,
            type: 'maven-wrapper'
          };
        }
      }
    }
    
    // Tests Gradle (Java/Kotlin)
    if (fs.existsSync('build.gradle') || fs.existsSync('build.gradle.kts')) {
      logger.info('üêò Tests Gradle d√©tect√©s...');
      if (shell.which('gradle')) {
        const testResult = shell.exec('gradle test');
        return {
          success: testResult.code === 0,
          output: testResult.stdout,
          error: testResult.stderr,
          type: 'gradle'
        };
      } else if (fs.existsSync('gradlew') || fs.existsSync('gradlew.bat')) {
        const wrapper = process.platform === 'win32' ? 'gradlew.bat' : './gradlew';
        const testResult = shell.exec(`${wrapper} test`);
        return {
          success: testResult.code === 0,
          output: testResult.stdout,
          error: testResult.stderr,
          type: 'gradle-wrapper'
        };
      }
    }
    
    // Tests Node.js
    if (fs.existsSync('package.json')) {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      if (packageJson.scripts?.test) {
        logger.info('üì¶ Tests npm d√©tect√©s...');
        const testResult = shell.exec('npm test');
        return {
          success: testResult.code === 0,
          output: testResult.stdout,
          error: testResult.stderr,
          type: 'npm'
        };
      }
    }
    
    // Tests Python
    if (fs.existsSync('requirements.txt') || fs.existsSync('pytest.ini') || fs.existsSync('tests/') || fs.existsSync('test/')) {
      logger.info('üêç Tests Python d√©tect√©s...');
      const testResult = shell.exec('python -m pytest -v --tb=short');
      return {
        success: testResult.code === 0,
        output: testResult.stdout,
        error: testResult.stderr,
        type: 'pytest'
      };
    }
    
    // Tests .NET
    if (fs.existsSync('*.sln') || shell.ls('*.csproj').length > 0) {
      logger.info('üî∑ Tests .NET d√©tect√©s...');
      const testResult = shell.exec('dotnet test');
      return {
        success: testResult.code === 0,
        output: testResult.stdout,
        error: testResult.stderr,
        type: 'dotnet'
      };
    }
    
    // Tests Go
    if (fs.existsSync('go.mod')) {
      logger.info('üêπ Tests Go d√©tect√©s...');
      const testResult = shell.exec('go test ./...');
      return {
        success: testResult.code === 0,
        output: testResult.stdout,
        error: testResult.stderr,
        type: 'go'
      };
    }
    
    // Makefile avec target test
    if (fs.existsSync('Makefile')) {
      const makefileContent = fs.readFileSync('Makefile', 'utf8');
      if (makefileContent.includes('test:')) {
        logger.info('üî® Tests Make d√©tect√©s...');
        const testResult = shell.exec('make test');
        return {
          success: testResult.code === 0,
          output: testResult.stdout,
          error: testResult.stderr,
          type: 'make'
        };
      }
    }
    
    logger.info('‚ö†Ô∏è  Aucun syst√®me de test automatis√© d√©tect√©');
    return { 
      success: true, 
      output: 'Aucun test automatis√© configur√© - validation par d√©faut', 
      error: null,
      type: 'none'
    };
  }

  async createMergeRequest(task, branchName, defaultBranch, taskDir) {
    shell.cd(taskDir);
    
    // Commit et push
    shell.exec('git add .');
    const commitMessage = `feat(${task.key}): ${task.summary}\n\n${task.description || ''}`;
    shell.exec(`git commit -m "${commitMessage}"`);
    shell.exec(`git push origin ${branchName}`);
    
    // MR via API GitLab
    const gitlabToken = process.env.GITLAB_ACCESS_TOKEN;
    const projectId = process.env.GITLAB_PROJECT_ID;
    
    if (!gitlabToken || !projectId) {
      logger.warn('‚ö†Ô∏è  Config GitLab manquante');
      return { success: false, message: 'Config GitLab manquante' };
    }
    
    const mergeRequestData = {
      source_branch: branchName,
      target_branch: defaultBranch,
      title: `[${task.key}] ${task.summary}`,
      description: `
## ü§ñ T√¢che automatis√©e par Claude Code

**T√¢che Jira:** [${task.key}](https://${process.env.JIRA_HOST}/browse/${task.key})

### Description
${task.description || 'Aucune description fournie'}

### Priorit√©
${task.priority || 'Non d√©finie'}

### Modifications r√©alis√©es
- Solution g√©n√©r√©e automatiquement par Claude Code
- Tests automatis√©s valid√©s
- Code pr√™t pour review

### Checklist de review
- [ ] Code review complet
- [ ] Tests suppl√©mentaires si n√©cessaire
- [ ] Documentation mise √† jour
- [ ] Approbation fonctionnelle

**Note:** Cette MR a √©t√© cr√©√©e automatiquement par l'int√©gration Jira-Claude.
      `,
      assignee_ids: task.assignee ? await this.getGitLabUserId(task.assignee) : undefined,
      labels: ['automation', 'claude-generated', task.priority?.toLowerCase()].filter(Boolean)
    };
    
    try {
      const axios = require('axios');
      const response = await axios.post(
        `https://gitlab.com/api/v4/projects/${projectId}/merge_requests`,
        mergeRequestData,
        {
          headers: {
            'Private-Token': gitlabToken,
            'Content-Type': 'application/json'
          }
        }
      );
      
      logger.info(`‚úÖ MR cr√©√©e: ${response.data.web_url}`);
      return {
        success: true,
        mergeRequestUrl: response.data.web_url,
        mergeRequestId: response.data.iid
      };
    } catch (error) {
      logger.error('‚ùå Erreur cr√©ation MR:', error.message);
      return { success: false, error: error.message };
    }
  }

  async getGitLabUserId(displayName) {
    return null; // Impl√©mentation simplifi√©e
  }

  prepareClaudePrompt(task, branchName) {
    return `
# T√¢che Jira: ${task.key}

## R√©sum√©
${task.summary}

## Description
${task.description || 'Aucune description fournie'}

## Priorit√©
${task.priority || 'Non d√©finie'}

## Labels
${task.labels.join(', ')}

## Contexte Git
- **Branche**: ${branchName}
- **Repository**: ${process.env.REPOSITORY_URL || 'Repository local'}
- **Branche par d√©faut**: ${process.env.DEFAULT_BRANCH || 'main'}

## Instructions d√©taill√©es
Vous travaillez sur une t√¢che Jira dans un environnement Git configur√©.

### 1. Analyse et compr√©hension
- Analysez le code existant dans le repository
- Identifiez les patterns et conventions utilis√©s
- Comprenez l'architecture du projet

### 2. Impl√©mentation
Si c'est une t√¢che de d√©veloppement :
- Cr√©ez/modifiez les fichiers n√©cessaires
- Respectez les conventions existantes
- Utilisez les m√™mes technologies que le projet
- Ajoutez des tests unitaires appropri√©s
- Documentez avec des commentaires clairs
- Mettez √† jour la documentation si n√©cessaire

### 3. Tests et validation
- Assurez-vous que tous les tests existants passent
- Ajoutez de nouveaux tests pour couvrir votre code
- V√©rifiez compilation/ex√©cution sans erreurs
- Validez le respect des standards de qualit√©

### 4. Technologies support√©es
Le syst√®me supporte automatiquement :
- **Java** : Maven (mvn test) et Gradle (gradle test)
- **Node.js** : npm test
- **Python** : pytest
- **.NET** : dotnet test
- **Go** : go test ./...
- **Make** : make test

### 5. Bonnes pratiques
- Suivez les principes SOLID
- G√©rez correctement les erreurs
- Optimisez les performances si n√©cessaire
- Assurez-vous de la s√©curit√© du code
- Respectez les normes d'accessibilit√© si applicable

### 6. Livrables attendus
- Code fonctionnel et test√©
- Tests automatis√©s qui passent
- Documentation mise √† jour
- Commits avec messages clairs

## Contraintes techniques
- Code pr√™t pour la production
- Tests automatis√©s doivent passer
- Respectez l'architecture existante
- Suivez les guidelines du projet

## Note importante
Cette t√¢che sera automatiquement test√©e. Si les tests passent, une Merge Request sera cr√©√©e et la t√¢che Jira passera en "Code Review".

Commencez par explorer le repository, puis impl√©mentez √©tape par √©tape.
`;
  }

  async executeTaskWithClaude(task) {
    try {
      logger.info(`üöÄ Ex√©cution ${task.key}: ${task.summary}`);
      
      // 1. Setup Git
      const { taskDir, branchName, defaultBranch } = await this.setupGitRepository(task);
      
      // 2. Prompt Claude
      const prompt = this.prepareClaudePrompt(task, branchName);
      
      // 3. Sauvegarder prompt
      await fs.writeFile(path.join(taskDir, 'task-prompt.md'), prompt);
      
      // 4. Claude Code
      const result = shell.exec(`claude-code "${prompt}"`, {
        silent: false,
        cwd: taskDir
      });
      
      if (result.code !== 0) {
        throw new Error(`Claude Code √©chec: ${result.code}: ${result.stderr}`);
      }
      
      // 5. Sauvegarder r√©sultats
      await fs.writeFile(path.join(taskDir, 'claude-output.txt'), result.stdout);
      
      // 6. Tests automatis√©s
      const testResults = await this.runAutomatedTests(taskDir);
      
      if (!testResults.success) {
        logger.error(`‚ùå Tests ${testResults.type} √©chou√©s`);
        return {
          success: false,
          error: `Tests ${testResults.type} √©chou√©s: ${testResults.error}`,
          testResults,
          taskDir,
          branchName
        };
      }
      
      logger.info(`‚úÖ Tests ${testResults.type} pass√©s`);
      
      // 7. Merge Request
      const mergeRequestResult = await this.createMergeRequest(task, branchName, defaultBranch, taskDir);
      
      return {
        success: true,
        output: result.stdout,
        taskDir,
        branchName,
        testResults,
        mergeRequest: mergeRequestResult
      };
      
    } catch (error) {
      logger.error(`‚ùå Erreur ${task.key}:`, error.message);
      return {
        success: false,
        error: error.message,
        taskDir: this.workingDir + '/' + task.key
      };
    }
  }

  async sendTeamsNotification(task, result) {
    const teamsWebhookUrl = process.env.TEAMS_WEBHOOK_URL;
    
    if (!teamsWebhookUrl) {
      logger.warn('‚ö†Ô∏è  TEAMS_WEBHOOK_URL non configur√©');
      return { success: false, message: 'Webhook URL manquant' };
    }
    
    try {
      const axios = require('axios');
      const card = this.buildTeamsCard(task, result);
      
      const response = await axios.post(teamsWebhookUrl, card, {
        headers: { 'Content-Type': 'application/json' }
      });
      
      logger.info('‚úÖ Notification Teams envoy√©e');
      return { success: true, response: response.status };
      
    } catch (error) {
      logger.error('‚ùå Erreur notification Teams:', error.message);
      return { success: false, error: error.message };
    }
  }

  buildTeamsCard(task, result) {
    const isSuccess = result.success && result.testResults?.success && result.mergeRequest?.success;
    const statusColor = isSuccess ? 'Good' : result.success ? 'Warning' : 'Attention';
    const statusIcon = isSuccess ? '‚úÖ' : result.success ? '‚ö†Ô∏è' : '‚ùå';
    const statusText = isSuccess ? 'Succ√®s complet' : result.success ? 'Succ√®s partiel' : '√âchec';
    
    const jiraUrl = `https://${process.env.JIRA_HOST}/browse/${task.key}`;
    const testType = result.testResults?.type || 'unknown';
    
    return {
      "@type": "MessageCard",
      "@context": "https://schema.org/extensions",
      "themeColor": statusColor === 'Good' ? '00FF00' : statusColor === 'Warning' ? 'FFA500' : 'FF0000',
      "summary": `T√¢che automatis√©e: ${task.key}`,
      "sections": [
        {
          "activityTitle": `${statusIcon} **Automatisation Claude Code**`,
          "activitySubtitle": `T√¢che ${task.key} - ${statusText}`,
          "facts": [
            {
              "name": "üé´ T√¢che",
              "value": `[${task.key}](${jiraUrl}) - ${task.summary}`
            },
            {
              "name": "‚ö° Priorit√©", 
              "value": task.priority || 'Non d√©finie'
            },
            {
              "name": "üë§ Assign√©",
              "value": task.assignee || 'Non assign√©'
            },
            {
              "name": "üåø Branche",
              "value": result.branchName || 'N/A'
            },
            {
              "name": "üß™ Tests",
              "value": result.testResults?.success ? `‚úÖ ${testType.toUpperCase()} pass√©s` : `‚ùå ${testType.toUpperCase()} √©chou√©s`
            },
            {
              "name": "üîÄ Merge Request",
              "value": result.mergeRequest?.success ? '‚úÖ Cr√©√©e' : '‚ùå Erreur'
            }
          ],
          "markdown": true
        }
      ],
      "potentialAction": this.buildTeamsActions(task, result, jiraUrl)
    };
  }

  buildTeamsActions(task, result, jiraUrl) {
    const actions = [
      {
        "@type": "OpenUri",
        "name": "üìã Voir la t√¢che Jira",
        "targets": [{ "os": "default", "uri": jiraUrl }]
      }
    ];

    if (result.mergeRequest?.success && result.mergeRequest.mergeRequestUrl) {
      actions.push({
        "@type": "OpenUri", 
        "name": "üîÄ Voir la Merge Request",
        "targets": [{ "os": "default", "uri": result.mergeRequest.mergeRequestUrl }]
      });
    }

    if (process.env.CI_PIPELINE_URL) {
      actions.push({
        "@type": "OpenUri",
        "name": "üìä Voir les logs CI/CD", 
        "targets": [{ "os": "default", "uri": process.env.CI_PIPELINE_URL }]
      });
    }

    return actions;
  }

  async sendTeamsProgressNotification(task, status = 'started') {
    const teamsWebhookUrl = process.env.TEAMS_WEBHOOK_URL;
    if (!teamsWebhookUrl) return { success: false };
    
    try {
      const axios = require('axios');
      const jiraUrl = `https://${process.env.JIRA_HOST}/browse/${task.key}`;
      
      const card = {
        "@type": "MessageCard",
        "@context": "https://schema.org/extensions", 
        "themeColor": "0078D4",
        "summary": `T√¢che ${task.key} ${status}`,
        "sections": [
          {
            "activityTitle": `üöÄ **Automatisation en cours**`,
            "activitySubtitle": `T√¢che ${task.key} - ${status === 'started' ? 'D√©marrage' : 'En cours'}`,
            "facts": [
              {
                "name": "üé´ T√¢che",
                "value": `[${task.key}](${jiraUrl}) - ${task.summary}`
              },
              {
                "name": "üìÖ D√©marr√© √†",
                "value": new Date().toLocaleString('fr-FR')
              },
              {
                "name": "ü§ñ Processus",
                "value": "Claude Code en action..."
              }
            ],
            "markdown": true
          }
        ]
      };
      
      await axios.post(teamsWebhookUrl, card);
      logger.info(`üì¢ Notification Teams: ${task.key} ${status}`);
      return { success: true };
      
    } catch (error) {
      logger.error('‚ùå Erreur notification progress:', error.message);
      return { success: false };
    }
  }

  async updateJiraTask(taskKey, result) {
    try {
      let comment, transition;
      const testType = result.testResults?.type || 'unknown';
      
      if (result.success) {
        comment = `‚úÖ **T√¢che automatis√©e avec succ√®s par Claude Code**

üìÅ **R√©pertoire**: ${result.taskDir}
üåø **Branche**: ${result.branchName}

## Tests automatis√©s (${testType.toUpperCase()})
${result.testResults.success ? '‚úÖ Tous les tests passent' : '‚ùå Tests √©chou√©s'}
\`\`\`
${result.testResults.output || 'Aucun output de test'}
\`\`\`

## Merge Request
${result.mergeRequest.success 
  ? `‚úÖ MR cr√©√©e automatiquement: ${result.mergeRequest.mergeRequestUrl}`
  : `‚ùå Erreur cr√©ation MR: ${result.mergeRequest.error || result.mergeRequest.message}`
}

**Prochaine √©tape**: Code Review requis avant merge.
        `;
        
        if (result.testResults.success && result.mergeRequest.success) {
          transition = await this.getJiraTransitionId(taskKey, 'Code Review');
        }
      } else {
        comment = `‚ùå **Erreur lors de l'automatisation**

**Erreur**: ${result.error}

${result.testResults ? `
## Tests automatis√©s (${testType.toUpperCase()})
${result.testResults.success ? '‚úÖ Tests OK' : '‚ùå Tests √©chou√©s'}
\`\`\`
${result.testResults.error || result.testResults.output || 'Pas de d√©tails'}
\`\`\`
` : ''}

${result.branchName ? `**Branche cr√©√©e**: ${result.branchName}` : ''}

**Action requise**: V√©rification manuelle n√©cessaire.
        `;
      }
      
      // Ajouter commentaire
      await this.jira.addComment(taskKey, comment);
      logger.info(`‚úÖ Commentaire ajout√© √† ${taskKey}`);
      
      // Transition si applicable
      if (transition) {
        try {
          await this.jira.transitionIssue(taskKey, { 
            transition: { id: transition.id },
            fields: {
              assignee: { name: result.task?.assignee || null },
              customfield_10000: result.mergeRequest.mergeRequestUrl
            }
          });
          logger.info(`‚úÖ ${taskKey} ‚Üí "Code Review"`);
        } catch (transitionError) {
          logger.error(`‚ùå Erreur transition ${taskKey}:`, transitionError.message);
        }
      }
      
      // Notification Teams
      const teamsNotification = await this.sendTeamsNotification(
        { key: taskKey, ...result.task }, 
        result
      );
      
      if (teamsNotification.success) {
        logger.info('üì¢ √âquipe notifi√©e via Teams');
      }
      
    } catch (error) {
      logger.error(`‚ùå Erreur mise √† jour ${taskKey}:`, error.message);
    }
  }

  async getJiraTransitionId(taskKey, targetStatus) {
    try {
      const transitions = await this.jira.listTransitions(taskKey);
      const transition = transitions.transitions.find(t => 
        t.name.toLowerCase().includes(targetStatus.toLowerCase()) ||
        t.to.name.toLowerCase().includes(targetStatus.toLowerCase())
      );
      
      if (transition) {
        logger.info(`‚úÖ Transition "${targetStatus}": ${transition.name} (${transition.id})`);
        return transition;
      } else {
        logger.warn(`‚ö†Ô∏è  Transition "${targetStatus}" non trouv√©e pour ${taskKey}`);
        return null;
      }
    } catch (error) {
      logger.error(`‚ùå Erreur transitions ${taskKey}:`, error.message);
      return null;
    }
  }

  async run() {
    try {
      await this.initialize();
      
      const tasks = await this.getTasksFromBacklog();
      logger.info(`üìã ${tasks.length} t√¢che(s) trouv√©e(s)`);
      
      const results = [];
      
      for (const task of tasks) {
        // Notification d√©marrage
        await this.sendTeamsProgressNotification(task, 'started');
        
        const result = await this.executeTaskWithClaude(task);
        results.push({ task, result });
        
        // Mise √† jour Jira (inclut notification Teams)
        await this.updateJiraTask(task.key, { ...result, task });
        
        // Pause entre t√¢ches
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
      
      // R√©sum√© final
      const successful = results.filter(r => r.result.success).length;
      const failed = results.length - successful;
      
      logger.info(`üéØ Termin√©: ${successful} r√©ussie(s), ${failed} √©chou√©e(s)`);
      
      return results;
      
    } catch (error) {
      logger.error('‚ùå Erreur g√©n√©rale:', error.message);
      throw error;
    }
  }
}

// Ex√©cution directe
if (require.main === module) {
  const automation = new JiraClaudeAutomation();
  automation.run().catch(error => {
    logger.error('üí• Erreur fatale:', error);
    process.exit(1);
  });
}

module.exports = JiraClaudeAutomation;